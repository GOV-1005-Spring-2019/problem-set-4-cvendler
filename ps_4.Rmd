---
title: 'Problem Set #4'
author: "Céline Vendler"
date: "2/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE,
                      error = FALSE, 
                      warning = FALSE)

# Load library "gt" in order to be able to create and format the chart in Question 2
library(gt)
library(tidyverse)

# Read in the file "ps_4_elections-poll-nc09-3.csv" and store as new dataset called "orig_data"
orig_data <- read_csv("ps_4_elections-poll-nc09-3.csv")
```

## Question 1

```{r mad_libs}
# To fill in Mad Lib 1, create a new dataset called "mad_lib_1" in order to replace the "X" with the content of "mad_lib_1" dynamically using inline R code (here, the content is a singular number); begin with the "orig_data" dataset
mad_lib_1 <- orig_data %>% 
  # Filter the data to keep only observations for respondents who responded "Dem"
  filter(response == "Dem") %>% 
  # Count the number of observations in order to determine the number of respondents who supported the Democratic candidate
  count()

# To fill in Mad Lib 2, create a new dataset called "mad_lib_2" in order to replace the "X" with the content of "mad_lib_2" dynamically using inline R code (here, the content is a singular number); begin with the "orig_data" dataset
mad_lib_2 <- orig_data %>% 
  # Filter the data to keep only observations for respondents who responded either "Rep" or "Und"
  filter(response %in% c("Rep", "Und")) %>% 
  # Count the observations by response (count the number of respondents who responded "Rep" and the number of respondents who responded "Und")
  count(response) %>% 
  # Spread the data using the variable "response" (the values of which are "Rep" and "Und") as the key and using the variable "n" (the values of which are the counts from above) as the value so that the dataset has two columns--one for "Rep" and one for "Und"--and one row, within which are the corresponding counts for "Rep" and "Und" responses
  spread(response, n) %>% 
  # Calculate the difference ("diff") between the count for Rep and the count for Und, reflecting how many more respondents there were who favored the Republican candidate than who were undecided
  summarize(diff = Rep - Und)
  
# To fill in Mad Lib 3, create a new dataset called "mad_lib_3" in order to replace the "X" with the content of "mad_lib_3" dynmically using inline R code (here, the content is a singular number); begin with the "orig_data" dataset
mad_lib_3 <- orig_data %>% 
  # Filter the data to keep only observations where the variables "gender" and "gender_combined" have different values
  filter(gender != gender_combined) %>% 
  # Count the number of observations in order to determine the number of individuals for whom the variables "gender" and "gender_combined" have different values
  count()

# To fill in Mad Lib 4, create a new dataset called "mad_lib_4" in order to replace the "X" with the content of "mad_lib_4" dynmically using inline R code (here, the content is a singular number); begin with the "orig_data" dataset
mad_lib_4 <- orig_data %>% 
  # Filter the data to keep only observations for respondents listed as "White" under "race_eth" but not listed as "White" under "file_race_black"
  filter(race_eth == "White", 
         file_race_black != "White") %>% 
  # Count the number of observations in order to determine the number of respondents listed as "White" under "race_eth" who are not listed as "White" under "file_race_black"
  count()

# To fill in Mad Lib %, create a new dataset called "mad_lib_5" in order to replace the "X" with the content of "mad_lib_5" dynmically using inline R code (here, the content is a singular number); begin with the "orig_data" dataset
mad_lib_5 <- orig_data %>% 
  # Filter the data to keep only observations for respondents who responded either "Dem" or "Rep"
  filter(response %in% c("Dem", "Rep")) %>% 
  # Group the data by the variable "response" in order to be able to compare first-response-timestamps across responses (here, "Dem" and "Rep")
  group_by(response) %>% 
  # Summarize the data in order to determine the timestamps of the first responses of "Dem" and "Rep" respectively ("first_response")
  summarize(first_response = min(timestamp)) %>% 
  # Spread the data using the varible "response" (the values of which are "Dem" and "Rep") as the key and using the variable "first_response" (the values of which are the timestamps of the first responses of "Dem" and "Rep" respectively) as the value so that the dataset has two columns--one for "Dem" and one for "Rep"--and one row, within which are the timestamp of the first "Dem" response and that of the first "Rep" response
  spread(response, first_response) %>% 
  # Calculate the time difference ("diff"), rounded to the nearest minute, between the timestamp of the first "Rep" response and that of the first "Dem" response in order to determine by how many minutes the first "Dem" response came before the first "Rep" response
  summarize(diff = round(Rep - Dem))
```

There were `r mad_lib_1` respondents who supported the Democratic candidate.

There were `r mad_lib_2` more respondents who favored the Republican candidate than who were Undecided.

There are two gender variables (`gender` and `gender_combined`). There are `r mad_lib_3` individuals for whom these variables have different values.

There are `r mad_lib_4` respondents listed as “White” under `race_eth` who are not listed as “White” under  `file_race_black`.

The first `response` of Dem came `r mad_lib_5` minutes (rounded to the nearest minute) before the first `response` of Rep.

## Question 2

```{r create_chart}
# Create a new dataset called "data_to_chart" to chart using gt; begin with the "orig_data" dataset
data_to_chart <- orig_data %>% 
  # Select only the variables pertinent to the chart, which are "response", "race_eth", and "final_weight"
  select(response, race_eth, final_weight) %>% 
  # Filter the data so that answers to "race_eth" that read "[DO NOT READ] Don't know/Refused" are excluded, per the instruction within the brackets: "DO NOT READ"
  filter(race_eth != "[DO NOT READ] Don't know/Refused") %>% 
  # Reorder the levels of the factor "race_eth" so that "White" is first, "Black" is second, "Hispanic" is third, "Asian" is fourth, and "Other" is fifth
  mutate(race_eth = fct_relevel(race_eth, c("White", 
                                            "Black", 
                                            "Hispanic", 
                                            "Asian", 
                                            "Other"))) %>% 
  # Group the data by the variables "race_eth" and "response" in order to calculate weighted totals (the sums of final weights) by combinations of "race_eth" and "response"
  group_by(race_eth, response) %>% 
  # Calculate "race_eth" and "response" combinations' respective weighted totals ("weighted_total") by summing the final weights within those combinations
  summarize(weighted_total = sum(final_weight)) %>% 
  # Spread the data using the varible "response" (the values of which are "3", "Dem", "Rep", and "Und") as the key and using the variable "weighted_total" (the values of which are the weighted totals of the "race_eth" and "response" combinations, respectively) as the value so that the dataset has five columns--"race_eth", "3", "Dem", "Rep", and "Und"--and five rows, within which are the values of "race_eth"--"White", "Black", "Hispanic", "Asian", and "Other"--and the weighted totals by "race_eth" and "response"; replace values of "NA" with 0
  spread(response, weighted_total, 
         fill = 0) %>% 
  # Ungroup the data in order to be able to manipulate individual (ungrouped) observations
  ungroup() %>% 
  # Create a new variable called "total_by_race_eth", the values of which are the sums of the values of the columns "3", "Dem", "Rep", and "Und" by "race_eth" (the sums of the weighted totals by "race_eth" and "response" for each "race_eth")
  mutate(total_by_race_eth = `3` + Dem + Rep + Und) %>% 
  # Alter the variable "Dem" by making its values equal to the original values of "Dem" divided by the corresponding values of "total_by_race_eth" so that the values of "Dem" are now decimals, reflecting the proportions of White, Black, Hispanic, Asian, and Other respondents who responded "Dem", respectively
  mutate(Dem = Dem / total_by_race_eth) %>% 
  # Alter the variable "Rep" by making its values equal to the original values of "Rep" divided by the values of "total_by_race_eth" so that the values of "Rep" are now decimals, reflecting the proportions of White, Black, Hispanic, Asian, and Other respondents who responded "Rep", respectively
  mutate(Rep = Rep / total_by_race_eth) %>% 
  # Alter the variable "Und" by making its values equal to the original values of "Und" divided by the corresponding values of "total_by_race_eth" so that the values of "Und" are now decimals, reflecting the proportions of White, Black, Hispanic, Asian, and Other respondents who responded "Und", respectively
  mutate(Und = Und / total_by_race_eth) %>% 
  # Deselect the variables "total_by_race_eth" and "3", as they are not needed anymore
  select(-c(total_by_race_eth, `3`)) %>% 
  # Set all values of 0 to "NA"
  na_if(0)

# Chart "data_to_chart" using functions from the library "gt"
gt(data_to_chart) %>% 
  # Give the chart a title; I chose to make my title "Polling Results from 3rd Wave for North Carolina's 9th Congressional District," as the data used is polling data from 3rd wave for North Carolina’s 9th Congressional District
  tab_header(title = "Polling Results from 3rd Wave for North Carolina's 9th Congressional District") %>% 
  # Give the chart a source note, citing The New York Times Upshot and Siena College and their 2018 live polls
  tab_source_note(source_note = "New York Times Upshot/Siena College 2018 live polls") %>% 
  # Relabel the chart's columns so that the label "race_eth" is removed, so that Dem reads "DEM.", so that Rep reads "REP.", and so that Und reads "UND."
  cols_label(race_eth = "", 
             Dem = "DEM.", 
             Rep = "REP.", 
             Und = "UND.") %>% 
  # Reformat the values in the rows corresponding to the columns "DEM.", "REP.", and "UND." so that the decimal values appear as whole-number percentages
  fmt_percent(columns = vars(Dem, Rep, Und), 
              decimals = 0) %>% 
  # Reformat the value housed in the fourth row of the "UND." column, which reads "NA", as a missing value, so that "NA" is replaced with an em-dash
  fmt_missing(columns = vars(Und), rows = 4)
```

## Question 3

```{r create_graphic, fig.width = 7.1}
# Create a new dataset called "data_to_plot" to plot using ggplot; begin with the "orig_data" dataset; set the width of the figure to 7.1 so that my subtitle does not get cut off when I knit this Rmd file (thank you to Jenny for this clever solution)
data_to_plot <- orig_data %>% 
  # Select only the variables pertinent to the plot, which are "educ" and "final_weight"
  select(educ, final_weight) %>% 
  # Filter the data so that answers to "educ" that read "[DO NOT READ] Refused" are excluded, per the instruction within the brackets: "DO NOT READ"
  filter(educ != "[DO NOT READ] Refused") %>% 
  # Reorder the levels of the factor "educ" so that "Grade school" is first, "High school" is second, "Some college or trade school" is third, "Bachelors' degree" is fourth, and "graduate or Professional Degree" is fifth
  mutate(educ = fct_relevel(educ, c("Grade school", 
                                    "High school", 
                                    "Some college or trade school", 
                                    "Bachelors' degree", 
                                    "Graduate or Professional Degree")))

# Plot data_to_plot; set "educ" as the x-axis variable and "final_weight" as the y-axis variable; these assignments will later be flipped using the "coord_flip" function, but the ultimate goal is to be able to visualize the density of weights given to respondents of various levels of education and to be able to make comparisons across levels of education
ggplot(data_to_plot, aes(x = educ, y = final_weight)) + 
  # Make the plot a violin plot so that the above goal can be accomplished
  geom_violin() + 
  # Flip the coordinates so that x becomes y and y becomes x; visually, "final_weight" appears as the x-axis variable, and "educ" appears as the y-axis variable
  coord_flip() + 
  # Add "jittered" points to the plot (add random variation to the locations of points); set height (which, because of the flipping of coordinates, really affects width) and width (which, for the same reason, really affects height) values for the random noise so that the points match those on the plot provided in the problem set as closely as possible; set alpha to 0.5 so that the points are semi-transparent (so that individual points appear grey and not black)
  geom_jitter(height = 0.1, width = 0.2, alpha = 0.5) + 
  # Remove the x-axis label (which, visually, appears as the y-axis label, so I am removing the label for all the educational levels on the plot); give the y-axis (which, visually, appears as the x-axis) the label "Weight Given to Respondent in Calculating Poll Results"; give the plot a title, subtitle, and caption to match the plot provided in the problem set
  labs(x = "", 
       y = "Weight Given to Respondent in Calculating Poll Results", 
       title = "More Educated Matter Less in North Carolina 9th", 
       subtitle = "Poll gives more weight to people who are less likely to participate in polls", 
       caption = "New York Times Upshot/Siena College 2018 live polls")
```